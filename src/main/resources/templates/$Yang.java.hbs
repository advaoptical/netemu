package {{{package}}};

import java.util.Collection;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.function.Function;
import java.util.stream.Stream;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import one.util.streamex.StreamEx;

import {{{yangPackage}}}.{{{yangClass}}};
import {{{yangPackage}}}.{{{yangClass}}}Builder;

{{#block "extended imports"}}
{{/block}}

import com.adva.netemu.YangData;


public class {{{class}}}$Yang {

    public static final class Data extends YangData<{{{yangClass}}}> {

        @Nonnull
        private static final Data EMPTY = new Data(null);

        private Data(@Nullable final {{{yangClass}}} object) {
            super(object);
        }

        @Nonnull
        public static Data of(@Nonnull final {{{yangClass}}} object) {
            return new Data(object);
        }

        @Nonnull
        public static Data from(@Nonnull final org.opendaylight.yangtools.concepts.Builder<{{{yangClass}}}> builder) {
            return new Data(builder.build());
        }

        @Nonnull
        public static Data empty() {
            return EMPTY;
        }

{{#each yangDataGetters}}
    {{#if this.valueIsList}}
        @Nonnull
        public Optional<List<{{{this.valueClass}}}>> get{{{@key}}}() {
            return super.map({{{yangClass}}}::get{{{@key}}});
        }

    {{else}}
        @Nonnull
        public Optional<{{{this.valueClass}}}> get{{{@key}}}() {
            return super.map({{{yangClass}}}::{{{this.getterName}}});
        }

    {{/if}}
{{/each}}
    }

{{#*inline "yangBuilder"}}
    public static final class {{{builderName}}} implements org.opendaylight.yangtools.concepts.Builder<{{{yangClass}}}> {

{{#each yangDataGetters}}
    {{#if this.valueIsList}}
        @Nullable
        private CompletableFuture<List<{{{this.valueClass}}}>> future{{{@key}}} = null;

        @Nonnull
        public {{{../builderName}}} set{{{@key}}}(@Nullable final Collection<{{{this.valueClass}}}> values) {
            this.future{{{@key}}} = (values != null) ? CompletableFuture.completedFuture(List.copyOf(values)) : null;
            return this;
        }

        @Nonnull
        public {{{../builderName}}} set{{{@key}}}(@Nonnull final {{{this.valueClass}}} ...values) {
            this.future{{{@key}}} = CompletableFuture.completedFuture(StreamEx.of(values).toImmutableList());
            return this;
        }

        @Nonnull
        public {{{../builderName}}} set{{{@key}}}(@Nonnull final Stream<{{{this.valueClass}}}> values) {
            this.future{{{@key}}} = CompletableFuture.completedFuture(StreamEx.of(values).toImmutableList());
            return this;
        }

        @Nonnull
        public {{{../builderName}}} set{{{@key}}}(@Nonnull final Optional<? extends Collection<{{{this.valueClass}}}>> values) {
            this.future{{{@key}}} = values.map(List::copyOf).map(CompletableFuture::completedFuture).orElse(null);
            return this;
        }

        @Nonnull
        public {{{../builderName}}} set{{{@key}}}(
                @Nonnull final CompletableFuture<? extends Collection<{{{this.valueClass}}}>> futureValues) {

            this.future{{{@key}}} = futureValues.thenApply(List::copyOf);
            return this;
        }

    {{else}}
        @Nullable
        private CompletableFuture<{{{this.valueClass}}}> future{{{@key}}} = null;

        @Nonnull
        public {{{../builderName}}} set{{{@key}}}(@Nullable final {{{this.valueClass}}} value) {
            this.future{{{@key}}} = (value != null) ? CompletableFuture.completedFuture(value) : null;
            return this;
        }

        @Nonnull
        public {{{../builderName}}} set{{{@key}}}(@Nonnull final Optional<{{{this.valueClass}}}> value) {
            this.future{{{@key}}} = value.map(CompletableFuture::completedFuture).orElse(null);
            return this;
        }

        @Nonnull
        public {{{../builderName}}} set{{{@key}}}(@Nonnull final CompletableFuture<{{{this.valueClass}}}> futureValue) {
            this.future{{{@key}}} = futureValue;
            return this;
        }

    {{/if}}

    {{#if this.valueHasBuilder}}

        {{> yangBuilder yangClass=this.valueClass builderName=this.builderName yangDataGetters=this.builderClassYangDataGetters}}

        {{#if this.valueIsList}}
        @Nonnull @SafeVarargs
        public final {{{../builderName}}} set{{{@key}}}(
                @Nonnull final Function<{{{builderName}}}, {{{builderName}}}> ...providers) {

            this.future{{{@key}}} = CompletableFuture.completedFuture(StreamEx.of(providers)
                    .map(provider -> provider.apply(new {{{builderName}}}()).build())
                    .toImmutableList());

            return this;
        }

        {{else}}
        @Nonnull
        public {{{../builderName}}} set{{{@key}}}(@Nonnull final Function<{{{builderName}}}, {{{builderName}}}> provider) {
            this.future{{{@key}}} = CompletableFuture.completedFuture(provider.apply(new {{{builderName}}}()).build());
            return this;
        }

        {{/if}}
    {{/if}}
{{/each}}

        @Nonnull @Override
        public {{{yangClass}}} build() {
            try {
                return new {{{yangClass}}}Builder()

{{#each yangDataGetters}}
                        .set{{{@key}}}((this.future{{{@key}}} != null) ? this.future{{{@key}}}.get() : null)
{{/each}}

                        .build();

            } catch (final ExecutionException | InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
{{/inline}}

{{> yangBuilder}}

    @Nonnull
    public static Optional<{{{class}}}{{{bindingClassSuffix}}}> bindingOf(@Nonnull final {{{class}}} object) {
        return object.{{{bindingGetter}}}().map({{{class}}}{{{bindingClassSuffix}}}.class::cast);
    }

    /*
    @Nonnull
    public static Data configurationDataFrom(@Nonnull final {{{class}}} object) {
        @Nullable final var data = bindingOf(object).map({{{class}}}{{{bindingClassSuffix}}}::provideConfigurationData)
                .orElse(null);

        return (data != null) ? Data.of(data) : Data.empty();
    }
    */

    @Nonnull
    public static Data operationalDataFrom(@Nonnull final {{{class}}} object) {
        @Nullable final var dataFuture = bindingOf(object).map({{{class}}}{{{bindingClassSuffix}}}::provideOperationalData);
        if (dataFuture.isPresent()) {
            @Nonnull final YangData<{{{yangClass}}}> data;
            try {
                data = dataFuture.get().get();

            } catch (final InterruptedException | ExecutionException e) {
                throw new RuntimeException(e.getCause());
            }

            if (data.isPresent()) {
                return Data.of(data.get());
            }
        }

        return Data.empty();
    }

{{#block "extended members"}}
{{/block}}
}
