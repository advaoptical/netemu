package {{{package}}};

import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import {{{yangPackage}}}.{{{yangClass}}};
import {{{yangPackage}}}.{{{yangClass}}}Builder;

{{#block "extended imports"}}
{{/block}}

import com.adva.netemu.YangData;


public class {{{class}}}$Yang {

    public static final class Data extends YangData<{{{yangClass}}}> {

        @Nonnull
        private static final Data EMPTY = new Data(null);

        private Data(@Nullable final {{{yangClass}}} object) {
            super(object);
        }

        @Nonnull
        public static Data of(@Nonnull final {{{yangClass}}} object) {
            return new Data(object);
        }

        @Nonnull
        public static Data from(@Nonnull final org.opendaylight.yangtools.concepts.Builder<{{{yangClass}}}> builder) {
            return new Data(builder.build());
        }

        @Nonnull
        public static Data empty() {
            return EMPTY;
        }

{{#each yangDataGetters}}
        @Nonnull
        public Optional<{{{this.valueClass}}}> {{{this.reprefixedName}}}() {
            return super.map({{{yangClass}}}::{{{@key}}});
        }
{{/each}}
    }

    public static final class Builder implements org.opendaylight.yangtools.concepts.Builder<{{{yangClass}}}> {

{{#each yangDataGetters}}
        @Nullable
        private CompletableFuture<{{{this.valueClass}}}> {{{this.futureName}}} = null;

        @Nonnull
        public Builder {{{this.setterName}}}(@Nullable final {{{this.valueClass}}} value) {
            this.{{{this.futureName}}} = (value != null) ? CompletableFuture.completedFuture(value) : null;
            return this;
        }

        @Nonnull
        public Builder {{{this.setterName}}}(@Nonnull final Optional<{{{this.valueClass}}}> value) {
            this.{{{this.futureName}}} = value.map(CompletableFuture::completedFuture).orElse(null);
            return this;
        }

        @Nonnull
        public Builder {{{this.setterName}}}(@Nonnull final CompletableFuture<{{{this.valueClass}}}> futureValue) {
            this.{{{this.futureName}}} = futureValue;
            return this;
        }
{{/each}}

        @Nonnull @Override
        public {{{yangClass}}} build() {
            try {
                return new {{{yangClass}}}Builder()

{{#each yangDataGetters}}
                        .{{{this.setterName}}}((this.{{{this.futureName}}} != null) ? this.{{{this.futureName}}}.get() : null)
{{/each}}

                        .build();

            } catch (final ExecutionException | InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }

    @Nonnull
    public static Optional<{{{class}}}{{{bindingClassSuffix}}}> bindingOf(@Nonnull final {{{class}}} object) {
        return object.{{{bindingGetter}}}().map({{{class}}}{{{bindingClassSuffix}}}.class::cast);
    }

    /*
    @Nonnull
    public static Data configurationDataFrom(@Nonnull final {{{class}}} object) {
        @Nullable final var data = bindingOf(object).map({{{class}}}{{{bindingClassSuffix}}}::provideConfigurationData)
                .orElse(null);

        return (data != null) ? Data.of(data) : Data.empty();
    }
    */

    @Nonnull
    public static Data operationalDataFrom(@Nonnull final {{{class}}} object) {
        @Nullable final var dataFuture = bindingOf(object).map({{{class}}}{{{bindingClassSuffix}}}::provideOperationalData);
        if (dataFuture.isPresent()) {
            @Nonnull final YangData<{{{yangClass}}}> data;
            try {
                data = dataFuture.get().get();

            } catch (final InterruptedException | ExecutionException e) {
                throw new RuntimeException(e.getCause());
            }

            if (data.isPresent()) {
                return Data.of(data.get());
            }
        }

        return Data.empty();
    }

{{#block "extended members"}}
{{/block}}
}
