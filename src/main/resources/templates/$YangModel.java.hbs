package {{package}};

import java.util.Optional;
import java.util.concurrent.atomic.AtomicReference;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import {{yangPackage}}.{{yangClass}};
import {{yangPackage}}.{{yangClass}}Builder;

import com.adva.netemu.YangBindable;
import com.adva.netemu.YangBinding;
import com.adva.netemu.YangProvider;


class {{class}}$YangModel implements YangBindable {

    public static final class Yang {

        public static final class Data extends YangData<{{yangClass}}> {

            @Nonnull
            private static final Data EMPTY = new Data(null);

            private Data(@Nullable final {{yangClass}} object) {
                super(object);
            }

            @Nonnull
            public static Data of(@Nonnull final {{yangClass}} object) {
                return new Data(object);
            }

            @Nonnull
            public static Data empty() {
                return EMPTY;
            }

{{#each yangDataGetters}}
            @Nonnull
            Optional<{{this.valueClass}}> {{this.reprefixedName}}() {
                return super.map({{yangClass}}::{{@key}});
            }
{{/each}}
        }

        @Nonnull
        public static Optional<{{class}}{{bindingClassSuffix}}> bindingOf(@Nonnull final {{class}} object) {
            return object.{{bindingGetter}}().map({{class}}{{bindingClassSuffix}}.class::cast);
        }

        /*
        @Nonnull
        public static Data configurationDataFrom(@Nonnull final {{class}} object) {
            @Nullable final var data = bindingOf(object).map({{class}}{{bindingClassSuffix}}::provideConfigurationData)
                    .orElse(null);

            return (data != null) ? Data.of(data) : Data.empty();
        }
        */

        @Nonnull
        public static Data operationalDataFrom(@Nonnull final {{class}} object) {
        @Nullable final var data = bindingOf(object).map({{class}}{{bindingClassSuffix}}::provideOperationalData).orElse(null);
            return (data != null) ? Data.of(data) : Data.empty();
        }
    }

    static class YangBindingConnector {

        private YangBindingConnector() {}
    }

    @Nonnull
    private final {{class}}{{bindingClassSuffix}} yangBinding = new {{class}}{{bindingClassSuffix}}();

    @Nonnull @Override
    public Optional<YangBinding<?, ?, ?>> getYangBinding() {
        return Optional.of(this.yangBinding);
    }

    @Nonnull
    private final AtomicReference<Yang.Data> data = new AtomicReference<>(Yang.Data.empty());

    @Nonnull
    public Yang.Data data() {
        return this.data;
    }

    public {{class}}$YangModel() {
        @Nonnull final var connector = new YangBindingConnector();

        this.yangBinding.appliesOperationalDataUsing(connector, this.data::set);
    }

{{#each yangDataGetters}}
    @Nonnull
    Optional<{{this.valueClass}}> {{this.reprefixedName}}() {
        return this.data.get().{{@key}}();
    }

    void {{this.setterName}}(@Nullable final {{this.valueClass}} value) {
        this.data.set(Yang.Data.of(new {{yangClass}}Builder(this.data.get().get()).{{this.setterName}}(value).build()));
    }
{{/each}}
}
