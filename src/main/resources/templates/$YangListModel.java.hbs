package {{{package}}};

import java.util.Collection;
import java.util.List;
import java.util.Optional;

import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Stream;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import com.google.common.util.concurrent.FluentFuture;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListeningExecutorService;
import com.google.common.util.concurrent.MoreExecutors;
import one.util.streamex.StreamEx;

import {{{yangPackage}}}.{{{yangClass}}};
import {{{yangPackage}}}.{{{yangClass}}}Builder;
import {{{yangPackage}}}.{{{yangClass}}}Key;

import com.adva.netemu.YangData;
import com.adva.netemu.YangListBindable;
import com.adva.netemu.YangListBinding;
import com.adva.netemu.YangListProvider;
import com.adva.netemu.driver.EmuDriver;


public abstract class {{{class}}}_YangListModel implements YangListBindable {

    public static class Yang {

        public static final class Data extends YangData<{{{yangClass}}}> {

            @Nonnull
            private static final Data EMPTY = new Data(null);

            private Data(@Nullable final {{{yangClass}}} object) {
                super(object);
            }

            @Nonnull
            public static Data of(@Nonnull final {{{yangClass}}} object) {
                return new Data(object);
            }

            @Nonnull
            public static Data empty() {
                return EMPTY;
            }

{{#each yangDataGetters}}
            @Nonnull
            public Optional<{{{this.valueClass}}}> get{{{@key}}}() {
                return super.map({{{yangClass}}}::{{{this.getterName}}});
            }
{{/each}}
        }

        @Nonnull
        public static Optional<{{{class}}}{{{bindingClassSuffix}}}> bindingOf(@Nonnull final {{{class}}} object) {
            return object.{{{bindingGetter}}}().map({{{class}}}{{{bindingClassSuffix}}}.class::cast);
        }

        /*
        @Nonnull
        public static Data configurationDataFrom(@Nonnull final {{{class}}} object) {
            @Nullable final var data = bindingOf(object).map({{{class}}}{{{bindingClassSuffix}}}::provideConfigurationData)
                    .orElse(null);

            return (data != null) ? Data.of(data) : Data.empty();
        }
        */

        @Nonnull
        public static Data operationalDataFrom(@Nonnull final {{{class}}} object) {
            @Nullable final var dataFuture = bindingOf(object).map({{{class}}}{{{bindingClassSuffix}}}::provideOperationalData);
            if (dataFuture.isPresent()) {
                @Nonnull final YangData<{{{yangClass}}}> data;
                try {
                    data = dataFuture.get().get();

                } catch (final InterruptedException | ExecutionException e) {
                    throw new RuntimeException(e.getCause());
                }

                if (data.isPresent()) {
                    return Data.of(data.get());
                }
            }

            return Data.empty();
        }

        public static class ListKey extends {{{yangClass}}}Key {

            private ListKey(@Nonnull final {{{keyClass}}} key) {
                super(key);
            }

            @Nonnull
            public static ListKey from(@Nonnull final {{{keyClass}}} key) {
                return new ListKey(key);
            }
        }

        @Nonnull
        public static StreamEx<{{{class}}}{{{bindingClassSuffix}}}> bindingStreamOf(
                @Nonnull final Collection<{{{class}}}> objects) {

            return StreamEx.of(objects).map(Yang::bindingOf).filter(Optional::isPresent).map(Optional::get);
        }

        /*
        @Nonnull
        public static StreamEx<{{{yangClass}}}> streamConfigurationDataFrom(@Nonnull final Collection<{{{class}}}> objects) {
            return streamConfigurationDataFrom(objects.stream());
        }

        @Nonnull
        public static StreamEx<{{{yangClass}}}> streamConfigurationDataFrom(@Nonnull final Stream<{{{class}}}> objects) {
            return StreamEx.of(objects).map(Yang::configurationDataFrom).filter(Data::isPresent).map(Data::get);
        }
        */

        @Nonnull
        public static StreamEx<{{{yangClass}}}> streamOperationalDataFrom(@Nonnull final Collection<{{{class}}}> objects) {
            return streamOperationalDataFrom(objects.stream());
        }

        @Nonnull
        public static StreamEx<{{{yangClass}}}> streamOperationalDataFrom(@Nonnull final Stream<{{{class}}}> objects) {
            return StreamEx.of(objects).map(Yang::operationalDataFrom).filter(Data::isPresent).map(Data::get);
        }
    }

    static class YangBindingConnector {

        private YangBindingConnector() {}
    }

    @Nonnull
    private final {{{class}}}{{{bindingClassSuffix}}} yangBinding;

    @Nonnull @Override
    public Optional<YangListBinding<?, ?, ?>> getYangListBinding() {
        return Optional.of(this.yangBinding);
    }

    @Nonnull
    private final AtomicReference<Yang.Data> data = new AtomicReference<>(Yang.Data.empty());

    @Nonnull
    public Yang.Data data() {
        return this.data.get();
    }

    public {{{class}}}_YangListModel(@Nonnull final Yang.ListKey key) {
        @Nonnull final var connector = new YangBindingConnector();
        this.yangBinding = {{{class}}}{{{bindingClassSuffix}}}.withKey(key)
                .appliesOperationalDataUsing(connector, this.data::set);
    }

    @Nonnull
    public CompletableFuture<Boolean> awaitOperationalDataApplying() {
        return this.yangBinding.awaitOperationalDataApplying();
    }

    @Nonnull
    private final AtomicReference<EmuDriver> driverSession = new AtomicReference<>(null);

    public void attachTo(@Nonnull final EmuDriver session) {
        this.driverSession.set(session);
    }

    @Nonnull
    private final ListeningExecutorService executor = MoreExecutors.listeningDecorator(new ScheduledThreadPoolExecutor(0));

    @Nonnull @SuppressWarnings({"UnstableApiUsage"})
    public FluentFuture<Yang.Data> update() {
        @Nullable final var session = this.driverSession.get();
        if (session != null) {
            return session.fetchOperationalData().transform(commitInfos -> {
                try {
                    this.yangBinding.provideOperationalData().get();

                } catch (final InterruptedException | ExecutionException e) {
                    throw new RuntimeException(e.getCause());
                }

                return this.data.get();

            }, this.executor);
        }

        return FluentFuture.from(Futures.immediateFuture(this.data.get()));
    }

{{~#each yangDataGetters}}

    @Nonnull
    public Optional<{{{this.valueClass}}}> get{{{@key}}}() {
        return this.data.get().get{{{@key}}}();
    }

    protected void set{{{@key}}}(@Nullable final {{{this.valueClass}}} value) {
        this.data.set(Yang.Data.of(new {{{yangClass}}}Builder(this.data.get().get()).set{{{@key}}}(value).build()));
    }

    @Nonnull
    public FluentFuture<Optional<{{{this.valueClass}}}>> update{{{@key}}}() {
        return this.update().transform(Yang.Data::get{{{@key}}}, this.executor);
    }
{{~/each}}
}
